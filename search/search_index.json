{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Marathon Marathon is a collection of modules designed to make using Dart on the server-side easier. Why Another Serverside Framework Maintained and maintainable: Every other notable server-side effort in Dart is abandoned or sporadically maintained. Most of these had issues because of their monolithic nature. Built in Dart: Dart is a nice language. It maintains readability and traditional C-style syntax while bringing modern languge features. Modular: it's based around shelf , a minimal web server built and maintained by the Dart team. You can use Marathon's routing, authentication, ORM, and more independently of each other. Clean and dependency-free: We've minimized third-party dependencies to avoid getting you in dependency hell. Well documented: Each module of Marathon has been extensively documented and planned to avoid unexpected behavior. Getting Started TBD","title":"Home"},{"location":"#welcome-to-marathon","text":"Marathon is a collection of modules designed to make using Dart on the server-side easier.","title":"Welcome to Marathon"},{"location":"#why-another-serverside-framework","text":"Maintained and maintainable: Every other notable server-side effort in Dart is abandoned or sporadically maintained. Most of these had issues because of their monolithic nature. Built in Dart: Dart is a nice language. It maintains readability and traditional C-style syntax while bringing modern languge features. Modular: it's based around shelf , a minimal web server built and maintained by the Dart team. You can use Marathon's routing, authentication, ORM, and more independently of each other. Clean and dependency-free: We've minimized third-party dependencies to avoid getting you in dependency hell. Well documented: Each module of Marathon has been extensively documented and planned to avoid unexpected behavior.","title":"Why Another Serverside Framework"},{"location":"#getting-started","text":"TBD","title":"Getting Started"},{"location":"cli/","text":"A few of the initial features for the marathon cli Initialise the main app. This would be the starting point for the server. It would contain configuration for the whole webserver like authentication backend, default database, fallback database , url , media routes , static files route etc. New apps Create New sub apps which would be mostly plug and play. Create a super user This would create an admin user which has superuser privileges i.e will be the master user. Can have multiple superusers. Start the server. The user can start the server on a specific port using this. It would support hot reloading. Some commands for the database. Some basic commands for the db like load fixtures, flush database, makemigrations , migrate db.","title":"CLI"},{"location":"cli/#a-few-of-the-initial-features-for-the-marathon-cli","text":"","title":"A few of the initial features for the marathon cli"},{"location":"cli/#initialise-the-main-app","text":"This would be the starting point for the server. It would contain configuration for the whole webserver like authentication backend, default database, fallback database , url , media routes , static files route etc.","title":"Initialise the main app."},{"location":"cli/#new-apps","text":"Create New sub apps which would be mostly plug and play.","title":"New apps"},{"location":"cli/#create-a-super-user","text":"This would create an admin user which has superuser privileges i.e will be the master user. Can have multiple superusers.","title":"Create a super user"},{"location":"cli/#start-the-server","text":"The user can start the server on a specific port using this. It would support hot reloading.","title":"Start the server."},{"location":"cli/#some-commands-for-the-database","text":"Some basic commands for the db like load fixtures, flush database, makemigrations , migrate db.","title":"Some commands for the database."},{"location":"authentication/api/","text":"","title":"API"},{"location":"authentication/different-approaches/","text":"This page describes how different frameworks handle authentication Django There is not much that goes into wile handling authentication in Django. Here's a brief overview of it. So the request coming in travels first to a session handler which sees if the session is valid its expiry date and suspicious activity so it deletes its session and a whole bunch of other things. Then the request travels down to authentication middleware. Before we jump into what authentication middleware does let's discuss user objects in Django. So there are 2 types of users by default Anonymous user and normal user . Normal User has fields like username, hashed password, first name, last name email, and different functions like is_authenticated. As in the case of Anonymous user as the name suggests it has methods like is_authenticated always return false. So coming back to authentication middleware, once the sessions in the request are validated \" sort of \"by the session middleware auth tries to see if there is a user that exists and attach that user object anonymous or existing user to the request object to be accessed internally easily. It also caches the users but I don't know-how. I find everything here quite structured. We take the heavy lifting from the user so that he doesn't have to worry about implementing jwt or sessions and all of that stuff and just focus on building stuff. Before all the session and auth middleware it also does a lot of other validations to prevent attacks by using csrf token, etc which would also be good to implement. I am gonna link some more resources down here if you wanna read more about it. Using the Django authentication system How to user Sessions","title":"Authentication Approaches"},{"location":"authentication/different-approaches/#this-page-describes-how-different-frameworks-handle-authentication","text":"","title":"This page describes how different frameworks handle authentication"},{"location":"authentication/different-approaches/#django","text":"","title":"Django"},{"location":"authentication/different-approaches/#there-is-not-much-that-goes-into-wile-handling-authentication-in-django-heres-a-brief-overview-of-it","text":"So the request coming in travels first to a session handler which sees if the session is valid its expiry date and suspicious activity so it deletes its session and a whole bunch of other things. Then the request travels down to authentication middleware. Before we jump into what authentication middleware does let's discuss user objects in Django. So there are 2 types of users by default Anonymous user and normal user . Normal User has fields like username, hashed password, first name, last name email, and different functions like is_authenticated. As in the case of Anonymous user as the name suggests it has methods like is_authenticated always return false. So coming back to authentication middleware, once the sessions in the request are validated \" sort of \"by the session middleware auth tries to see if there is a user that exists and attach that user object anonymous or existing user to the request object to be accessed internally easily. It also caches the users but I don't know-how. I find everything here quite structured. We take the heavy lifting from the user so that he doesn't have to worry about implementing jwt or sessions and all of that stuff and just focus on building stuff. Before all the session and auth middleware it also does a lot of other validations to prevent attacks by using csrf token, etc which would also be good to implement. I am gonna link some more resources down here if you wanna read more about it. Using the Django authentication system How to user Sessions","title":"There is not much that goes into wile handling authentication in Django. Here's a brief overview of it."},{"location":"authentication/overview/","text":"","title":"Overview"},{"location":"sessions/specification/","text":"Marathon Sessions (Specification) This is an internal design document for Marathon's sessions module. What are sessions? Sessions are key to providing a reactive user experience on the server. Essentially, the idea is that the server stores some data set correspondent to a user id. Responses can then leverage the data associated with that user id (the \"session\" data) to provide a customized user experience. Essentially, without some sort of session management, we couldn't customize our services on a per-user basis! For example, imagine trying to build a banking service without the server knowing who the user is. It doesn't work, does it? Session IDs are typically stored using cookies, which are a type of storage mechanism in browsers. This cookie is transmitted along with every request; the presence (or lack thereof) of a valid session ID in a request can indicate a user's status with the system. Session Security There are a few vectors of attack on a typical session-based system. The simplest is just a brute force attack: by trying enough different user IDs, an attacker could gain access to user data. This is why session IDs must always be UUIDs, or another such construct with a low chance of collision. A more advanced attacker might think to record a user's user ID and then send it to the server, thereby gaining access to all the user's data and privileges. While it's practically impossible to ENSURE that a client won't leak this data, we should take steps to mitigate the likelihood. This includes: HTTPS only communication (plain HTTP is insecure and could leak the cookie with the ID) Setting an expiry on the session cookie (The session ID is automatically deleted ~30 min after it's received by the client, unless it's re-received). API Design If you are not familiar with the shelf library , I highly recommend you read the documentation there before reading this API design. This design will gloss over concepts and classes introduced there, mostly in the interest of brevity and simple code snippets. Basics Marathon sessions should be convenient middleware on a shelf server. This means something like: var app = Pipeline().addMiddleware(sessionManager()).addHandler(_performSessionBasedActions); This sessionManager function should, internally, construct a SessionManager object, and attach it to the Request. shelf Requests have a property Map<String, dynamic> context , which the middleware can write to. The manager can thus be attached to the context in the middleware, and then read and used from a handler. For example: Response _performSessionBasedActions(Request req) { var sessionManger = req.context['sessions'] as SessionManager; // perform some actions with sessionManager return Response.ok('yay!'); } SessionManager I've made references to a SessionManager class without explaining its purpose. Essentially, the SessionManager is responsible for providing the user an interface to read/edit/refresh sessions. SessionManager should have the following parameters (optional parameters are italicized with their default values beside them): boolean cookieHttpOnly = true : exposes session id cookie's httpOnly attribute Duration cookieMaxAge = Duration(minutes: 30) : exposes session id cookie's maxAge attribute, with a sane, secure default. boolean cookieSecure = false : exposes session id cookie's secure attribute, which limits the cookie to being only transmittable over HTTPS. Though this is HIGHLY recommended for production servers, it can cause issues in dev environments, so the default is false. String Function() genID = _uuidGenerator : the function to call when generating a new session ID. This should, by default, use a function that generates a UUID. String cookieName = 'marathon.sid' : the name of the session ID cookie. The session ID will be written into the Response header under this cookieName and read from the Request header under this cookieName. SessionStore store : the store abstraction containing all the user sessions. Explained in depth in the next section. Method, Property lists TBD. SessionStore In the SessionManager docs, I made some references to a SessionStore class. This \"class\" is really an abstract class meant to be implemented as an interface. It should essentially provide CRUD methods, with User IDs as the keys. I won't go into too much detail on the abstract class; it should be noted that the onus is on the user of this library to implement the SessionStore interface (and thereby provide a way of storing user sessions). We should provide a Map-backed implementation (perhaps \"LocalSessionStore\"), which is purely for development and testing purposes. Of course, this is not a real solution: storing user-sessions in memory is absurd. However, providing such an implementation allows users of this library to test and run their servers without actually using a full SessionStore. When we eventually provide ORM services, it should definitely implement this interface, so that the ORMs can be used as SessionStores without any struggles.","title":"Specification"},{"location":"sessions/specification/#marathon-sessions-specification","text":"This is an internal design document for Marathon's sessions module.","title":"Marathon Sessions (Specification)"},{"location":"sessions/specification/#what-are-sessions","text":"Sessions are key to providing a reactive user experience on the server. Essentially, the idea is that the server stores some data set correspondent to a user id. Responses can then leverage the data associated with that user id (the \"session\" data) to provide a customized user experience. Essentially, without some sort of session management, we couldn't customize our services on a per-user basis! For example, imagine trying to build a banking service without the server knowing who the user is. It doesn't work, does it? Session IDs are typically stored using cookies, which are a type of storage mechanism in browsers. This cookie is transmitted along with every request; the presence (or lack thereof) of a valid session ID in a request can indicate a user's status with the system.","title":"What are sessions?"},{"location":"sessions/specification/#session-security","text":"There are a few vectors of attack on a typical session-based system. The simplest is just a brute force attack: by trying enough different user IDs, an attacker could gain access to user data. This is why session IDs must always be UUIDs, or another such construct with a low chance of collision. A more advanced attacker might think to record a user's user ID and then send it to the server, thereby gaining access to all the user's data and privileges. While it's practically impossible to ENSURE that a client won't leak this data, we should take steps to mitigate the likelihood. This includes: HTTPS only communication (plain HTTP is insecure and could leak the cookie with the ID) Setting an expiry on the session cookie (The session ID is automatically deleted ~30 min after it's received by the client, unless it's re-received).","title":"Session Security"},{"location":"sessions/specification/#api-design","text":"If you are not familiar with the shelf library , I highly recommend you read the documentation there before reading this API design. This design will gloss over concepts and classes introduced there, mostly in the interest of brevity and simple code snippets.","title":"API Design"},{"location":"sessions/specification/#basics","text":"Marathon sessions should be convenient middleware on a shelf server. This means something like: var app = Pipeline().addMiddleware(sessionManager()).addHandler(_performSessionBasedActions); This sessionManager function should, internally, construct a SessionManager object, and attach it to the Request. shelf Requests have a property Map<String, dynamic> context , which the middleware can write to. The manager can thus be attached to the context in the middleware, and then read and used from a handler. For example: Response _performSessionBasedActions(Request req) { var sessionManger = req.context['sessions'] as SessionManager; // perform some actions with sessionManager return Response.ok('yay!'); }","title":"Basics"},{"location":"sessions/specification/#sessionmanager","text":"I've made references to a SessionManager class without explaining its purpose. Essentially, the SessionManager is responsible for providing the user an interface to read/edit/refresh sessions. SessionManager should have the following parameters (optional parameters are italicized with their default values beside them): boolean cookieHttpOnly = true : exposes session id cookie's httpOnly attribute Duration cookieMaxAge = Duration(minutes: 30) : exposes session id cookie's maxAge attribute, with a sane, secure default. boolean cookieSecure = false : exposes session id cookie's secure attribute, which limits the cookie to being only transmittable over HTTPS. Though this is HIGHLY recommended for production servers, it can cause issues in dev environments, so the default is false. String Function() genID = _uuidGenerator : the function to call when generating a new session ID. This should, by default, use a function that generates a UUID. String cookieName = 'marathon.sid' : the name of the session ID cookie. The session ID will be written into the Response header under this cookieName and read from the Request header under this cookieName. SessionStore store : the store abstraction containing all the user sessions. Explained in depth in the next section. Method, Property lists TBD.","title":"SessionManager"},{"location":"sessions/specification/#sessionstore","text":"In the SessionManager docs, I made some references to a SessionStore class. This \"class\" is really an abstract class meant to be implemented as an interface. It should essentially provide CRUD methods, with User IDs as the keys. I won't go into too much detail on the abstract class; it should be noted that the onus is on the user of this library to implement the SessionStore interface (and thereby provide a way of storing user sessions). We should provide a Map-backed implementation (perhaps \"LocalSessionStore\"), which is purely for development and testing purposes. Of course, this is not a real solution: storing user-sessions in memory is absurd. However, providing such an implementation allows users of this library to test and run their servers without actually using a full SessionStore. When we eventually provide ORM services, it should definitely implement this interface, so that the ORMs can be used as SessionStores without any struggles.","title":"SessionStore"}]}